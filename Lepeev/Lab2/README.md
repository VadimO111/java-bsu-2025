# Bank Transaction System

Проект представляет собой реализацию банковской транзакционной системы на языке Java. Приложение обеспечивает управление пользователями и счетами, а также выполнение финансовых операций в асинхронном режиме. Особое внимание уделено архитектуре приложения, использованию паттернов проектирования (GoF) и обеспечению целостности данных.

## Технический стек
*   **Язык:** Java 17
*   **Сборка:** Maven
*   **База данных:** H2 (Embedded)
*   **GUI:** Java Swing
*   **Многопоточность:** `java.util.concurrent`

---

## 1. Базовый концепт и Архитектура

### Что такое UUID?
UUID (Universally Unique Identifier) — это 128-битный идентификатор, стандарт RFC 4122. В отличие от последовательных целочисленных идентификаторов (`Sequence`), UUID гарантирует глобальную уникальность объектов в распределенных системах без необходимости централизованной координации. В данном проекте UUID используется в качестве первичных ключей для сущностей `User`, `Account` и `Transaction`, что обеспечивает масштабируемость системы и исключает коллизии данных.

### Оценка архитектуры и улучшения
Базовая архитектура, предполагающая хранение списка счетов непосредственно внутри объекта пользователя, является неоптимальной для промышленных систем из-за проблем с производительностью при большом объеме данных (Lazy Loading issue).

**Внедренные архитектурные улучшения:**
1.  **Слой доступа к данным (DAO):** Реализован паттерн DAO (`AccountDao`, `UserDao`, `TransactionDao`). Логика персистентности полностью отделена от бизнес-логики и моделей данных.
2.  **Нормализация данных:** Связь между пользователем и счетом реализована через внешний ключ (`user_uuid`) в таблице счетов, что соответствует принципам реляционных баз данных.
3.  **Сервисный слой:** Вся бизнес-логика инкапсулирована в классе `BankService`, который выступает фасадом для GUI.

---

## 2. Принципы SOLID

Реализация проекта демонстрирует применение принципов SOLID:

*   **S (Single Responsibility Principle):** Разделение ответственности выполнено на уровне слоев: DAO отвечают за SQL-запросы, Service — за транзакционную логику, GUI — за отображение.
*   **O (Open/Closed Principle):** Система открыта для расширения новых типов операций через паттерн Стратегия. Добавление новой операции (например, "Кэшбэк") не требует модификации существующего кода обработки транзакций.
*   **L (Liskov Substitution Principle):** Сервисный слой взаимодействует с абстракцией `TransactionStrategy`. Любая реализация стратегии (`DepositStrategy`, `WithdrawStrategy`, `FreezeStrategy`) корректно заменяет базовый интерфейс без нарушения логики работы программы.
*   **I (Interface Segregation Principle):** Используются узкоспециализированные интерфейсы (`Command`, `Visitor`, `TransactionStrategy`), что предотвращает зависимость классов от неиспользуемых методов.
*   **D (Dependency Inversion Principle):** Модули верхнего уровня (`BankService`) зависят от абстракций, а не от деталей реализации. Взаимодействие с UI осуществляется через функциональный интерфейс `Consumer` (Observer pattern).

---

## 3. Паттерны проектирования

В системе реализованы следующие паттерны GoF:

| Паттерн | Применение в проекте |
| :--- | :--- |
| **Singleton** | Класс `DatabaseConnection` обеспечивает единую точку доступа к соединению с БД. |
| **Strategy** | Инкапсуляция алгоритмов выполнения транзакций (`Deposit`, `Withdraw`, `Freeze`). |
| **Factory Method** | Класс `TransactionFactory` отвечает за создание экземпляров стратегий на основе типа операции. |
| **Command** | Класс `TransactionCommand` инкапсулирует параметры запроса (сумма, ID, тип) для последующей передачи в асинхронную очередь. |
| **Observer** | Класс `EventManager` реализует механизм подписки, позволяя интерфейсу (GUI) автоматически обновляться при изменении состояния модели. |
| **Visitor** | Класс `BankReportVisitor` реализует операцию генерации финансового отчета, проходя по иерархии объектов пользователей и счетов. |

---

## 4. Асинхронность и Атомарность

### Механизмы Java
Для обеспечения высокой пропускной способности используется `ExecutorService` (Fixed Thread Pool). Это позволяет обрабатывать поток транзакций фиксированным числом рабочих потоков, предотвращая исчерпание системных ресурсов при высокой нагрузке.

### Обеспечение атомарности
Атомарность операций и защита от состояния гонки (Race Condition) обеспечиваются на двух уровнях:
1.  **Application Level:** Использование блока `synchronized` на мониторе объекта `Account` внутри стратегии гарантирует, что изменение баланса конкретного счета выполняется потокобезопасно.
2.  **Database Level:** Использование транзакционных механизмов СУБД H2 гарантирует целостность данных при записи (ACID).

---

## Инструкция по запуску

Для корректной работы приложения требуется установленный JDK 17+ и Maven.

1.  Открыть проект в среде разработки (IntelliJ IDEA).
2.  Выполнить синхронизацию Maven (Reload Project) для загрузки зависимостей (драйвер H2).
3.  Запустить класс `com.bank.Main`.